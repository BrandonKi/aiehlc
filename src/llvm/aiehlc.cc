/******************************************************************************
* Copyright (C) 2025 Advanced Micro Devices, Inc. All Rights Reserved.
* SPDX-License-Identifier: MIT
******************************************************************************/

#include "../../include/gcommon.h"
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Frontend/FrontendAction.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Instructions.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "clang/AST/Decl.h"

//#include "AieFrontEnd.h"
#include "../mlir/mlirfront/AieFrontEnd.h"
#include <boost/algorithm/string.hpp>

#include <ios>
#include <iostream>
#include <fstream>
#include <ostream>
#include <sstream>
#include <cstdlib> 

class AieFrontEnd;

static bool use_llvm_aie = false;
static std::vector<std::string> kernel_name_list;

using namespace clang;
using namespace clang::tooling;
class GlobalFunctionVisitor : public RecursiveASTVisitor<GlobalFunctionVisitor> {
private:
	std::string GetFuncText(FunctionDecl *f) {
		clang::SourceRange functionRange = f->getSourceRange();
		clang::SourceLocation startLocation = functionRange.getBegin();
		clang::SourceLocation endLocation = Rewrite->getSourceMgr().getExpansionLoc(functionRange.getEnd());
		clang::SourceLocation endLocationWithOffset = clang::Lexer::getLocForEndOfToken(endLocation, 0, Rewrite->getSourceMgr(), Rewrite->getLangOpts());
		bool InvalidTemp = false;
		std::string fullkernel;
		clang::StringRef text = Rewrite->getSourceMgr().getBufferData(Rewrite->getSourceMgr().getFileID(startLocation), &InvalidTemp);
		if (!InvalidTemp) {
			const char* begin = text.begin() + Rewrite->getSourceMgr().getFileOffset(startLocation);
			const char* end = text.begin() + Rewrite->getSourceMgr().getFileOffset(endLocationWithOffset);
			std::string functionString(begin, end);
			fullkernel = functionString;
		} else {
			std::cerr << "Error: Unable to access the buffer for the original function text.\n";
			return "";
		}
		std::string str(fullkernel.data(), fullkernel.size());
		return str;
	}
	void ReplaceKernel(FunctionDecl *f) {
		return;
	}
public:
    explicit GlobalFunctionVisitor(Rewriter* Rewrite, ASTContext *Context, AieFrontEnd* Aiefrontend)
        : Context(Context), Rewrite(Rewrite) , Aiefrontend(Aiefrontend){
			 std::ofstream kl(AOUT+std::string("kernel_list"), std::ios::out);
		}

     void ExportFunction(FunctionDecl *FD, std::string kname) {
	     /*
        if (FD->hasBody()) {
            llvm::outs() << FD->getNameAsString() << " Function Body:\n";
            FD->getBody()->printPretty(llvm::outs(), nullptr, PrintingPolicy(Context->getLangOpts()));
            llvm::outs() << "\n\n";
        }*/
			llvm::outs() << "Exporting File: " << AOUT+std::string("kernel_list") << "\n\n";
			 std::ofstream kl(AOUT+std::string("kernel_list"), std::ios::app | std::ios::out);
			 kl << kname << std::endl;
			 kl.close();

			 std::error_code error_code;
			 //change the ext from .c into .cc to fix the aiecompiler compile issue
			llvm::outs() << "Exporting File: " << AOUT+kname + ".cc" << "\n";
			 std::ofstream fd(AOUT+kname + ".cc");
			 auto str = GetFuncText(FD);
			 //std::string toRemove = "__attribute__((annotate(\"__global__\")))";
			//fixme, shoud only remove mem_address and global annotate attribute, correct way is to do
      // one more pass to remove the related attribute
			 std::string toRemove = "__attribute__";
			 size_t pos, prepos=std::string::npos;
			 while((pos = str.find(toRemove)) != std::string::npos){
         //avoid infinite loop
				 if (prepos != std::string::npos && prepos == pos) break;
				 prepos = pos;
         //the remove logic
				 auto nstr = str.substr(pos + toRemove.size());
				 auto npos = nstr.find("(");
				 if (npos == std::string::npos) break;
				 auto cstr = nstr.c_str();
				 int lb = 1;
				 while(lb && npos < nstr.size()) {
					 auto c = cstr[++npos];
					 lb += (c == '(' ? 1 :(c == ')' ? -1 : 0) );
					 //std::cout << "npos is " << npos << " "<<lb << " is lb cstr is " << &cstr[npos]<< std::endl;
				 }
				 str.erase(pos, toRemove.size() + npos + 1);
				 //avoid infinite loop, reset prepos
				 prepos = std::string::npos;
			 }
             std::string header =
			     "/******************************************************************************"
                 "\n* Auto-generated by aiehlc.\n"
                 "******************************************************************************/";
			 // llvm aie can not handle these headers yet, results in compile errors
			 if(use_llvm_aie) {
				header += 
				 "\n#include <adf.h>\n\n"
				//  "\n#include <aie_api/aie.hpp>\n"
				//  "\n#include <aie_api/aie_adf.hpp>\n"
				//  "\n#include <aie_api/utils.hpp>\n\n";
				;
			 }
			 else {
				header += 
				 "\n#include <adf.h>"
				 "\n#include <aie_api/aie.hpp>"
				 "\n#include <aie_api/aie_adf.hpp>"
				 "\n#include <aie_api/utils.hpp>\n\n";
			 }
             str = header + str;
			 fd << str << std::endl;
    }

		 void printSourceRange(const clang::SourceRange &range, const clang::SourceManager &sourceManager) {
			 llvm::outs() << "SourceRange: ";

			 // Get the start and end locations
			 clang::SourceLocation startLoc = range.getBegin();
			 clang::SourceLocation endLoc = range.getEnd();

			 // Print the file name
			 auto& sc = Rewrite->getSourceMgr();
			 llvm::outs() << sourceManager.getFilename(startLoc).str() << ":";
			 llvm::outs() << sourceManager.getFilename(endLoc).str() << ":";

			 ///*
			 // Print the start line and column
			 llvm::outs() << sourceManager.getSpellingLineNumber(startLoc) << ":" << sourceManager.getSpellingColumnNumber(startLoc) << "-";

			 // Print the end line and column
			 llvm::outs() << sourceManager.getSpellingColumnNumber(endLoc) << ":" << sourceManager.getSpellingColumnNumber(endLoc) << "\n";
			 //*/
		 }
		 bool VisitFunctionDecl(FunctionDecl *f) {
			 if (f->hasBody() && f->hasAttr<AnnotateAttr>()) {
				for (auto attr:f->attrs()) {
					if (auto anno = clang::dyn_cast<clang::AnnotateAttr>(attr)){
						if (anno->getAnnotation() == "__global__" || anno->getAnnotation() == "__kernel__") {
							std::string kernelName = f->getNameInfo().getName().getAsString();

							// std::cout << "find global " << f->getNameInfo().getName().getAsString() << std::endl;
							ParmVarDecl *param = f->getParamDecl(0);
							// llvm::outs() << "param->hasAttrs() is " << param->hasAttrs() << "\n";
							//llvm::outs << "range is " << range <<"\n";
							ExportFunction(f, kernelName);
							clang::SourceRange functionRange = f->getSourceRange();
							clang::SourceLocation startLocation = functionRange.getBegin();

							clang::SourceLocation lineStart = Rewrite->getSourceMgr().translateLineCol(
							Rewrite->getSourceMgr().getFileID(startLocation), 
							Rewrite->getSourceMgr().getSpellingLineNumber(startLocation), 1);
							Rewrite->RemoveText(f->getSourceRange());
							// do other rewrite logic only after the RemoveText work done
							Aiefrontend->createKernelDefinitionOp(f, Rewrite, lineStart);
							if (anno->getAnnotation() == "__global__") {
								std::string globalVars =
									"\n// Global variables for kernel: " + kernelName + "\n" +
									"extern unsigned char _binary_kernel_" + kernelName + "_start[];\n" +
									"extern unsigned char _binary_kernel_" + kernelName + "_end[];\n" +
									"extern unsigned int _binary_kernel_" + kernelName + "_size;\n\n";
								Rewrite->InsertText(lineStart, globalVars, true, true);
							} else if(anno->getAnnotation() == "__kernel__") {
							/*
							std::string templatedef = 
								"template <int Col, int Row, int colstart, int rowstart,typename... Args> \n \
								inline void " + kernelName + "(Args&&... args) {\n \
								return;\n \
								};";
							Rewrite->InsertText(lineStart, templatedef, true, true);
							*/
							
							}
						} else {
							std::cerr << "not global func" << std::endl;
						}
						auto range = f->getSourceRange();
						auto& sc = Rewrite->getSourceMgr();
						// std::cout << "range.isValid() " << range.isValid() <<std::endl;
						// printSourceRange(range,  sc);
					}
					for (unsigned int i = 0; i < f->getNumParams(); ++i) {
						ParmVarDecl *param = f->getParamDecl(i);
						// llvm::outs() << "  Param " << (i + 1) << ": type: "
						// 	<< param->getType().getAsString() << "  name:"
						// 	<< param->getNameAsString() << "\n";
					}
				}
			}
			Stmt *body = f->getBody();
			TraverseStmt(body);

			 //PrintCode();
			 // This involves manipulating the AST node of the function
			 return true;
		 }
		 std::string GetCallExprString(const CallExpr *  CE) {
			 std::ostringstream ostr;
			 const FunctionDecl *Callee = CE->getDirectCallee();
			 if (Callee) {
				 ostr << Callee->getNameAsString() << "(";
				 
				 //const Expr *thirdArgExpr = CE->getArg(2)->IgnoreImpCasts();
				 //std::string functionName = "";
				 //if (const clang::StringLiteral *strLit = clang::dyn_cast<clang::StringLiteral>(thirdArgExpr)) {
					// functionName = strLit->getString().str();
					 // Use 'functionName' as needed...
				//	 std::cout<< "load kernel functionName " << functionName << std::endl; 
				 //}
				 auto num = CE->getNumArgs();			
				 for (unsigned i = 0; i < num; i++) {
					 const clang::Expr* arg = CE->getArg(i);
					 clang::QualType argType = arg->getType();
					//  std::cout << "x- Parameter " << i << " type: ";
					//  std::cout << argType.getAsString();
					//  std::cout << std::endl;
					 if (auto *DRE = dyn_cast<DeclRefExpr>(arg->IgnoreImpCasts())) {
						 if (const VarDecl *VD = dyn_cast<const VarDecl>(DRE->getDecl())) {
							 ostr << VD->getNameAsString() ;
							 ostr << ((i<num-1) ? ",":" ");
						 }
					 } else if (auto *CallAsArg = dyn_cast<CallExpr>(arg)) {
							 ostr << GetCallExprString(CallAsArg);
							 ostr << ((i<num-1) ?",":" ");
					 } else if(const clang::PointerType *ptrType = argType->getAs<clang::PointerType>()) {
						 // Check if the pointee type is char (indicating char* or const char*)
						 clang::QualType pointeeType = ptrType->getPointeeType();
						 if (pointeeType->isCharType()) {
							 std::string argStr;
							 llvm::raw_string_ostream os(argStr);
							 arg->printPretty(os, nullptr, PrintingPolicy(LangOptions()));
							//  llvm::outs() << "Pretty printed argument " << i << ": " << os.str() << "\n";
							 ostr<< os.str() <<((i<num-1) ? ",":" ");
							 /*
							 if (const DeclRefExpr *declRef = dyn_cast<const DeclRefExpr>(arg->IgnoreParenImpCasts())) {
								 const ValueDecl *valueDecl = declRef->getDecl();

								 // Get the name of the function or variable
								 std::string paramName = valueDecl->getNameAsString();
								 llvm::outs() << "Pointer parameter name: " << paramName << "\n";
							 }
							 // Evaluate the expression
							 //clang::Expr::EvalResult evalResult;
							 //if (arg->EvaluateAsRValue(evalResult, *Context)) {
							 ///	clang::APValue value = evalResult.Val;
								//auto str = clang::dyn_cast<clang::StringLiteral>(CE->getArg(i)->IgnoreImpCasts());
							  //ostr << str->getString().str() << ((i<num-1) ? ",":" ");
							 //char* charArray = const_cast<char*>(value.getCharPtr().getPointer());
							 //	std::cout << " it is string " << str->getString().str() << " " << value.getCharPtr().getPointer() << std::endl;*/
							 }
						} else if (const CStyleCastExpr *castExpr = dyn_cast<const CStyleCastExpr>(arg)) {
								 // Get the expression being cast
								 const Expr *subExpr = castExpr->getSubExpr();

								 // Check if it's a reference to a variable
								 if (const DeclRefExpr *declRef = dyn_cast<const DeclRefExpr>(subExpr)) {
									 // Get the variable declaration
									 const ValueDecl *valueDecl = declRef->getDecl();

									 // Retrieve and print the name of the variable
									//  llvm::outs() << "Variable name: " << valueDecl->getName() << "\n";
									 ostr<< valueDecl->getName().str() <<((i < num -1) ?",":" ");
								 }
						} else if (argType->isIntegerType()) {
						 clang::Expr::EvalResult xResult;
						 if (arg->EvaluateAsInt(xResult, Callee->getASTContext())) {
							 int v = xResult.Val.getInt().getExtValue();
							 ostr << v ;
							 ostr<< ((i < num -1) ?",":" ");
						 }
					 }else {
						std::string argStr;
						llvm::raw_string_ostream os(argStr);
						arg->printPretty(os, nullptr, PrintingPolicy(LangOptions()));
						ostr << os.str() << ((i < num - 1) ? "," : " ");
					 }
				 }
			 }

			 ostr<< ")";
			 return ostr.str();
		}
		 //*/

		 bool VisitCallExpr(const CallExpr * 	CE) {
			const FunctionDecl *Callee = CE->getDirectCallee();
			if (Callee && Callee->getNameAsString() =="XAie_LoadElfMem") {
				//  std::cout << GetCallExprString(CE) <<std::endl;
				 auto fstr =GetCallExprString(CE) ;
				 std::size_t lastCommaPos = fstr.find_last_of(',');
    		 	 std::string kernel = fstr.substr(lastCommaPos + 1);
         		 std::string beforeLastComma = fstr.substr(0, lastCommaPos);
				 
				 auto kpos = kernel.find_last_of(')');
			     kernel = kernel.substr(0,kpos);
			     kpos=kernel.find_last_of(')');
				 if (kpos != std::string::npos) {
						kernel = kernel.substr(kpos + 1);
				 }
				 boost::algorithm::trim(kernel);
				 kernel = "_binary_kernel_" + kernel + "_start";
				 beforeLastComma += "," + kernel + ")";
				//  std::cout << beforeLastComma << std::endl;

				 clang::SourceRange callExprRange = CE->getSourceRange();
				 Rewrite->ReplaceText(callExprRange, beforeLastComma);
			} else {
					if (Callee) {
						for (auto x:kernel_name_list) {
							// std::cout << "kernel name is (" << x << ")" <<std::endl;
							if (Callee->getNameAsString() == x) {
								llvm::outs()<< "**************Function name is " << Callee->getNameInfo().getName().getAsString() <<"*********8\n";
							
								if (auto FD = CE->getDirectCallee()) {

									// 2) Check if it’s actually a specialization of a function template:
									if (auto  TSI = FD->getTemplateSpecializationInfo()) {
								
										// 3) Grab the FunctionTemplateDecl (the “template name”):
										auto FTD = FD->getPrimaryTemplate();
										llvm::outs() << "Template name: "
													<< FTD->getNameAsString() << "\n";
									
										// 4) Extract the explicit template-argument list:
										ArrayRef<TemplateArgument> Args = 
											TSI->TemplateArguments->asArray();
									
										llvm::outs() << "Template args: <";
										std::vector<std::string> knames;
										for (size_t i = 0; i < Args.size(); ++i) {
											const TemplateArgument &Arg = Args[i];
											llvm::SmallString<16> Buf;
											switch (Arg.getKind()) {
											case TemplateArgument::Integral:
												
												Arg.getAsIntegral().toString(Buf, 10);
												llvm::outs() << Buf;
												//std::string kname(Buf.begin(), Buf.end());
												//kname = Buf.str().str();
												knames.push_back(Buf.str().str());
												break;
											case TemplateArgument::Type:
												llvm::outs() << Arg.getAsType().getAsString();
												break;
											default:
												llvm::outs() << "(other)";
											}
											if (i + 1 < Args.size()) llvm::outs() << ", ";
										}
										llvm::outs() << ">\n\n";
										Aiefrontend->createKernelFunction(knames);
									}
								}
								
							}
						}
					} else {
						auto Call = CE->getCallee();
						if (Call) {
							//llvm::errs() << "Indirect function call or function pointer dereference\n";
							//Call->dump();  // You can inspect the callee expression
						}
					}
            // If Callee is null, it may be an indirect function call or a function pointer.
            // You can handle those cases accordingly.
            //llvm::outs() << "Indirect function call or function pointer\n";
			}
			return true;
    }
/*
		 bool VisitParmVarDecl(ParmVarDecl *PVD) {
        // Handle function parameters
        if (!PVD->hasInit()) {
          // Parameter does not have an initializer
          llvm::outs() << "Parameter without initializer: " << PVD->getNameAsString() << "\n";
        }
        return true;
      }

      bool VisitVarDecl(VarDecl *VD) {
        // Handle local variables
        if (!VD->hasInit()) {
          // Variable does not have an initializer
          llvm::outs() << "Variable without initializer: " << VD->getNameAsString() << "\n";
        }
        return true;
     }
		  bool VisitDecl(Decl *D) {
        // Check for "unknown type name 'windows'" error
				//std::cout << "unknow VisitDecl" <<std::endl;
				//return false;
				std::cout << "Decl is " << D->getDeclKindName() << std::endl;
        if (isa<UnresolvedUsingTypenameDecl>(D)) {
        }

        return true;
      }
			*/

		 void PrintCode() {
    	// Apply the rewrite to the source file
    	//Rewrite.commit(rewriter::Rewriter::Commit);
			//std::string RewrittenCode = Rewrite.getEditBuffer(Rewrite.getSourceMgr().getMainFileID()).getBuffer();
			 std::cout << "---------****---------" << std::endl;
			 ///*
			 const RewriteBuffer *RewriteBuf = Rewrite->getRewriteBufferFor(Rewrite->getSourceMgr().getMainFileID());
			 if (RewriteBuf) {
        //llvm::outs() << "Rewritten Source Code:\n" << RewriteBuf << "\n";
			//*/
			 //std::ofstream fd("./new_t.c");
				 RewriteBuf->write(llvm::outs());
		 }
			 /*
			 auto& sc = Rewrite.getSourceMgr();
			 auto mid = sc.getMainFileID();
			 llvm::StringRef sourceCode = sc.getBufferData(mid);
			 llvm::outs() << "Original Source Code:\n" << sourceCode << "\n";
			 */
			 std::cout << "------------------" << std::endl;
			//llvm::outs() << "Rewritten Source Code:\n" << RewrittenCode << "\n";
  	}


private:
		AieFrontEnd* Aiefrontend;
    ASTContext *Context;
		Rewriter *Rewrite;
};

class MyASTConsumer : public ASTConsumer {
public:
    //explicit MyASTConsumer(ASTContext *Context)
      //  : Visitor(Context) {}

    explicit MyASTConsumer(Rewriter* TheRewriter, ASTContext *Context, AieFrontEnd* Aiefrontend)
        : Visitor(TheRewriter, Context, Aiefrontend) {}

    void HandleTranslationUnit(ASTContext &Context) override {
        Visitor.TraverseDecl(Context.getTranslationUnitDecl());
		// std::cout << __FUNCTION__ << " get called " << std::endl;
    }

private:
    GlobalFunctionVisitor Visitor;
};

class MyFrontendAction : public ASTFrontendAction {
public:
		MyFrontendAction() {
			FileMgr = std::make_unique<clang::FileManager>(clang::FileSystemOptions());
			aiefrontend.set_llvm_aie(use_llvm_aie);
		}
		void ReplaceGlobalKeyAndAddInclude(clang::SourceManager &SourceMgr) {
			std::unordered_map<std::string, std::string> replace_map={{"__global__","__attribute__((annotate(\"__global__\")))"},
																	  {"__kernel__","__attribute__((annotate(\"__kernel__\")))"}};
			//auto SourceCodeString = GetKeyReplaceAndAddInclude(SourceMgr, "__global__",
			//		"__attribute__((annotate(\"__global__\")))");
			auto SourceCodeString = GetKeyReplaceAndAddInclude(SourceMgr, replace_map);
			llvm::StringRef ModifiedCode = SourceCodeString;

			std::unique_ptr<llvm::MemoryBuffer> ModifiedBuffer =
					 llvm::MemoryBuffer::getMemBufferCopy(ModifiedCode,"NewCode");
			// std::cout << "new ----------" << code << std::endl;
			// auto src = code.c_str();
			// std::cout << "new ---src-------" << src << std::endl;

			//const char* src = "__attribute__((annotate(\"__global__\"))) int func () {} \n int main() {}";
			//std::unique_ptr<llvm::MemoryBuffer> Buf = llvm::MemoryBuffer::getMemBuffer(src);
			const FileEntryRef SourceFile = FileMgr->getVirtualFileRef("newfile.cpp", ModifiedBuffer->getBufferSize(), 0);
			//FileEntryRef fileEntryRef = SourceMgr.translateFile(SourceFile);

			SourceMgr.overrideFileContents(SourceFile, std::move(ModifiedBuffer));
			FileID MainFileID = SourceMgr.getOrCreateFileID(SourceFile, SrcMgr::C_User);
			SourceMgr.setMainFileID(MainFileID);
		}
	 /* do pre-processing change the __global__ into annotation
	  */
	  bool BeginSourceFileAction(CompilerInstance &CI) override {
			//auto& ppopts = CI.getPreprocessorOpts();
			// std::cout <<"File is " << "Filename.str()" << std::endl;
 			clang::SourceManager &SourceMgr = CI.getSourceManager();

			ReplaceGlobalKeyAndAddInclude(SourceMgr);
			return true;
		}

		std::string GetKeyReplaceAndAddInclude(clang::SourceManager &SourceMgr, std::unordered_map<std::string,std::string>& funcMap) {
			std::string ret;
			// Get the main file entry
			const auto FileEntryRef = SourceMgr.getFileEntryRefForID(SourceMgr.getMainFileID());

			if (FileEntryRef) {
				// Get the file name
				llvm::StringRef FileName = FileEntryRef->getName();

				// Print or use the file name as needed
				// llvm::outs() << "Processing file: " << FileName << "\n";
				clang::FileID MainFileID = SourceMgr.getMainFileID();

				// Get the source code buffer for the main file
				//const llvm::MemoryBuffer *MainFileBuffer = SourceMgr.getBuffer(MainFileID);
				const auto MainFileBufferOp = SourceMgr.getBufferOrNone(MainFileID);
				const llvm::MemoryBufferRef *MainFileBuffer = &MainFileBufferOp.value();
				// Get the source code as a StringRef
				llvm::StringRef SourceCode = MainFileBuffer->getBuffer();
				// std::cout << SourceCode.str() << std::endl;
				std::unique_ptr<llvm::MemoryBuffer> Buffer = llvm::MemoryBuffer::getMemBuffer(SourceCode, "", false);

				llvm::SourceMgr SM;
				SM.AddNewSourceBuffer(std::move(Buffer), llvm::SMLoc());
				//replace keyword with annotate
				//std::string KeywordToReplace = sOld;//"__global__";
				//std::string Replacement = sNew;//"__attribute__((annotate(\"__global__\")))";

				//llvm::StringRef UpdatedSource;
				std::string SourceCodeString = SourceCode.str();
				size_t KeywordPos = 0;
				for (auto x:funcMap ) {
					std::string KeywordToReplace = x.first;//"__global__";
					std::string Replacement = x.second;//"__attribute__((annotate(\"__global__\")))";
					size_t KeywordPos = 0;
					while ((KeywordPos =  SourceCodeString.find(KeywordToReplace, KeywordPos)) != std::string::npos) {
						int pos = KeywordPos;
						bool bgstr = false;
						// check whether the __global_ is inside a '"', actually just check the front '"'
						while(--pos >=0) {
							if (SourceCodeString[pos] == ' ') continue;
							if (SourceCodeString[pos] == '"' || SourceCodeString[pos] == '/' || SourceCodeString[pos] == '*') {
								bgstr = true;
							}
							break;
						}
						if (!bgstr) {
							//process the kernel logic
							auto curkeywordpos = KeywordPos;
							if (KeywordToReplace == "__kernel__") {
								auto bracepos = SourceCodeString.find("(", curkeywordpos);
								auto curpos = bracepos;
								while(--curpos >=0){
									if (SourceCodeString[curpos] == ' ') break;
								}
								curpos++;
							
								auto str = SourceCodeString.substr(curpos, bracepos - curpos);
								while(str[str.size() -1] == ' ') {
									str = str.substr(0, str.size() - 1);
								}
								kernel_name_list.push_back(str);
							}
							//replace
							SourceCodeString.replace(KeywordPos, KeywordToReplace.size(), Replacement);
							KeywordPos += Replacement.size();
							//
							
						} else {
							KeywordPos += KeywordToReplace.size();
						}
					}
				}
				//ret = "#include <stdio.h>\n";
				//ret += "#include \"adf.h\"\n";
				// if(use_llvm_aie) {
				// 	ret += "typedef int input_window_int32;\n";
				// 	ret += "typedef int output_window_int32;\n";
				// }
				///*
				for (auto x:kernel_name_list) {
					ret += "template <int Col, int Row, int colstart, int rowstart,int M, int N, int K, typename... Args> \
 									    inline void "+ x +"(Args&&... args) { \
 										return; \
 										};\n";
				}
										//*/
				ret += SourceCodeString;
				// std::cout << ret << std::endl;
				/*
					 llvm::StringRef ModifiedCode = SourceCodeString;
					 std::unique_ptr<llvm::MemoryBuffer> ModifiedBuffer =
					 llvm::MemoryBuffer::getMemBufferCopy(ModifiedCode," Filename");

					 SourceMgr.overrideFileContents(FileEntry, std::move(ModifiedBuffer));

				// Get the modified file name
				llvm::StringRef ModifiedFileName = SourceMgr.getFileEntryForID(SourceMgr.getMainFileID())->getName();

				// Print modified file name
				llvm::outs() << "Modified file name: " << ModifiedFileName  << ModifiedCode<< "\n";
				*/
			}
			return ret;
		}

		void EndSourceFileAction() override {
			//  std::cout << "---------EndSourceFileAction---------" << std::endl;
			 const RewriteBuffer *RewriteBuf = TheRewriter.getRewriteBufferFor(TheRewriter.getSourceMgr().getMainFileID());
			 if (RewriteBuf) {
				 //RewriteBuf->write(llvm::outs());
        //llvm::outs() << "Rewritten Source Code:\n" << RewriteBuf << "\n";
	  		} else {
					llvm::errs() << "RewriteBuf is null\n";
				}
			 std::error_code error_code;
			 llvm::outs() << "Exporting File: " << std::string(AOUT)+"./host.cc" << "\n";
			 llvm::raw_fd_ostream outFile(std::string(AOUT)+"./host.cc", error_code, llvm::sys::fs::OF_None);
			 if (error_code) {
				 llvm::errs() << "Error opening file: " << error_code.message() << "\n";
				 return ;  // Exit early if there's an error
			 }
			 //fd.write(RewriteBuf->data(), RewriteBuf->size());
			 RewriteBuf->write(outFile);
			 /*
			 auto& sc = Rewrite.getSourceMgr();
			 auto mid = sc.getMainFileID();
			 llvm::StringRef sourceCode = sc.getBufferData(mid);
			 llvm::outs() << "Original Source Code:\n" << sourceCode << "\n";
			 */
			 const std::string fname = "aie.mlir";
			 auto mlirstr = aiefrontend.dumpir();
			 std::ofstream ofs(fname);
			 if (ofs.is_open()) {
					ofs << mlirstr;
					ofs.close();
			 }
			 aiefrontend.RunPass(fname);
			//  std::cout << "----------------end-----------------" << std::endl;
  	}
    std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
                                                   StringRef file) override {

				//disable the error information
			    // auto& dg = CI.getDiagnostics();
				// auto& Context = CI.getASTContext();
				// unsigned IgnoredErrorID = Context.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error,
				// 		"This error is ignored");
				// dg.setClient(new IgnoringDiagConsumer(), /*ShouldOwn=*/true);
				// CI.createDiagnostics(new IgnoringDiagConsumer(), /*ShouldOwnClient=*/false);

				TheRewriter.setSourceMgr(CI.getSourceManager(), CI.getLangOpts());			
        return std::make_unique<MyASTConsumer>(&TheRewriter,&CI.getASTContext(), &aiefrontend);
    }
private:
		std::string code;
		AieFrontEnd aiefrontend;
		Rewriter TheRewriter;
		std::unique_ptr<clang::FileManager> FileMgr;
		//FileManager FileMgr;
};
extern void dumpmlir();

void trycreatefolder(std::string dirPath) {
	///*
	std::string command = "mkdir -p " + dirPath; 
	int result = system(command.c_str());           // Run the command

	if (result == 0) {
		// std::cout << "Directory created." << std::endl;
	} else {
		std::cerr << "Failed to create directory." << std::endl;
	}
}

static llvm::cl::opt<std::string> IncludePath(
			"I", llvm::cl::desc("Specify include path (-I)"), llvm::cl::value_desc("path"));

llvm::cl::OptionCategory MyToolCategory("aiehlc options");
static llvm::cl::opt<bool> LLVMAie(
			"use-llvm-aie", llvm::cl::desc("Enable use of LLVM AIE"), llvm::cl::init(false), llvm::cl::cat(MyToolCategory));

int main(int argc, const char **argv) {

	trycreatefolder(AOUT);
	// std::cout << "main--" << IncludePath.getValue() << std::endl;
	// /*
    //CommonOptionsParser exp(argc, argv, MyToolCategory);
    ///*
	if (argc > 2) {
		if (strcmp(argv[1], "pass") == 0) {
			const char * mlirf = argv[2];
			AieFrontEnd af;
			std::string smlir(mlirf);
			af.Parser(smlir);
			return 0;
		}
	}
    auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory, llvm::cl::OneOrMore);
    if (!ExpectedParser) {
		llvm::errs() << "Error: " << llvm::toString(ExpectedParser.takeError()) << "\n";
        // Handle error
        return 1;
    }
    CommonOptionsParser &OptionsParser = ExpectedParser.get();
	use_llvm_aie = LLVMAie;
    //*/
    /*
    auto& OriginalCompilations = OptionsParser.getCompilations();
    std::vector<CompileCommand> newCommands;
    for (const auto& SourceFile : OptionsParser.getSourcePathList()) {
        auto CompileCommandsForFile = OriginalCompilations.getCompileCommands(SourceFile);
	for (auto &Command : CompileCommandsForFile) {
            Command.CommandLine.push_back("-x");
            Command.CommandLine.push_back("c++");
	    newCommands.push_back(Command);
	}

    }
    /*
    FixedCompilationDatabase ( "/scratch/staff/huaj/mlir/acompiler/build/../src/llvm/", newCommands);
    auto NewCompilations = std::make_shared<FixedCompilationDatabase>(newCommands);
		        //    "/scratch/staff/huaj/mlir/acompiler/build/../src/llvm/", newCommands);
    //ClangTool Tool(*NewCompilations,
    //               OptionsParser.getSourcePathList());
    
    std::string Directory = "/scratch/staff/huaj/mlir/acompiler/build/../src/llvm/";
    const char* CompileArgs[]= {"-std=c++11", " -x", "c++"};
    int n = 3;
    auto Compilations = FixedCompilationDatabase::loadFromCommandLine(n, CompileArgs, Directory);
    */
		//dumpmlir();
    ClangTool Tool(OptionsParser.getCompilations(),
                   OptionsParser.getSourcePathList());

	if (!IncludePath.empty()) {
		// Add the -I include path argument before the source file arguments
		Tool.appendArgumentsAdjuster(
				getInsertArgumentAdjuster(("-I" + IncludePath).c_str(), ArgumentInsertPosition::BEGIN));
	}
    return Tool.run(newFrontendActionFactory<MyFrontendAction>().get());
}
